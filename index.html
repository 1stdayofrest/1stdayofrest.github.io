<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="余生的第一天">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="余生的第一天">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="太阳战士">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>余生的第一天</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余生的第一天</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/code-rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/code-rpc/" class="post-title-link" itemprop="url">code-rpc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:44" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:44+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="分布式事务的讲解与实现"><a href="#分布式事务的讲解与实现" class="headerlink" title="分布式事务的讲解与实现"></a>分布式事务的讲解与实现</h3><pre><code>基础的ACID等等就不一一介绍了
有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><p>##简介：</p>
<pre><code>基础的ACID等等就不一一介绍了，柔性事务一类的大家在网上一搜都是，可以先看看基础的！
我的github都是实际操作加讲解，我觉得写文章大篇大论浪费时间，不如实际操作来的深刻
感谢大家支持！

1.tcc事务演进与场景
2.tcc事务源码解析与实际操作
3.分布式事务的实操与演进</code></pre><ol start="2">
<li><p><strong>TCC事务的简介</strong></p>
<p>  两段式事务</p>
<p>  <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/liangduanshi.JPG" alt="整体流程"></p>
<p>  三段式事务</p>
<p>  <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/tcc.JPG" alt="整体流程"></p>
</li>
</ol>
<pre><code>TCC的优点：
1.解决了扩应用的业务操作的原子性问题
2.数据库的二阶段提交提到了应用层实现
使用场景:

组合支付，账务一类的 比较要求强一致性高的场景使用

Tcc项目地址:</code></pre><p>   <a href="https://github.com/changmingxie/tcc-transaction/tree/master-1.2.x" target="_blank" rel="noopener"><img src="tcc%E5%9C%B0%E5%9D%80" alt="地址"></a></p>
<pre><code>如果你想 用dubbo的他的还不行有点错误请下载： (使用请先参考TCC文档)</code></pre><p>   <a href="https://github.com/qiurunze123/tcc-dubbo" target="_blank" rel="noopener"><img src="tcc-dubbo%E5%9C%B0%E5%9D%80" alt="地址"></a></p>
<p>   效果图：</p>
<p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/tcc.gif" alt="效果图"></p>
<pre><code>|_tcc-transaction-dubbo|
                       |_1 字节码代理 -&gt; 创建接口的代理对象
                       |_2 DubboTransactionContextEditor -&gt; TRANSACTION_CONTEXT[标识事务状态]利用Dubbo的隐式参数来传递关键的非业务数据
|_tcc-transaction-spring|
                        |_封装了一些关键的Spring组件

|_questions|
           |_1、什么时候生成的TRANSACTION_CONTEXT隐式参数
           |_2、如何判断一个大的事务下，都有哪些小的事务
           |_3、为什么要有@Compensable注解
           |_4、两个拦截器都没有处理Confirm和Cancel

|_基础概念 |
          |_主事务和分支事务【事务参与者】
          |_事务拦截器作用：[Spring AOP的基本概念要熟练掌握]|_1 CompensableTransactionInterceptor
                                                                                            |_ 将事务区分为Root事务和分支事务
                                                                                            |_不断的修改数据库内的状态【初始化事务，修改事务状态】
                                                                                            |_注册和清除事务管理器中队列内容
                                                        |_ResourceCoordinatorInterceptor
                                                                                        |_主要处理try阶段的事情
                                                                                        |_在try阶段，就将所有的&quot;资源&quot;封装完成并交给事务管理器
                                                                                        |_资源 -- 事务资源
                                                                                                  事务的参与者
                                                                                                             |_1.Confirm上下文
                                                                                                             |_2.Cancel上下文
                                                                                                             |_3.分支事务信息
                                                                                                             |_4.事务管理器修改数据库状态    

                                                        |_ 调用目标对象 -- order red cap                                                                        

|_小结
     |_ 1.事务的相关信息【全局事务编号，乐观锁版本等要持久化存储】
     |_ 2.资源：* TCC 【try-confirm-cancel】 try核心点： 预留业务资源  把事务数据资源存入库中 
     |_    3 流程： 
                 |_注册和初始化事务
                 |_组织事务参与者
                 |_执行目标try方法
                 |_执行confirm和cancel方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/code-solve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/code-solve/" class="post-title-link" itemprop="url">code-solve</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:44" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:44+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="秒杀常见问题"><a href="#秒杀常见问题" class="headerlink" title="秒杀常见问题"></a>秒杀常见问题</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><blockquote>
<p>秒杀注意事项以及整体简略设计</p>
</blockquote>
<h4 id="1-如何解决卖超问题"><a href="#1-如何解决卖超问题" class="headerlink" title="1.如何解决卖超问题"></a><a href="">1.如何解决卖超问题</a></h4><pre><code>--在sql加上判断防止数据边为负数 
--数据库加唯一索引防止用户重复购买
--redis预减库存减少数据库访问　内存标记减少redis访问　请求先入队列缓冲，异步下单，增强用户体验</code></pre><h4 id="注册功能-–-如果有前端的牛人加入修改几个页面那是再好不过了哈哈哈"><a href="#注册功能-–-如果有前端的牛人加入修改几个页面那是再好不过了哈哈哈" class="headerlink" title="注册功能 – 如果有前端的牛人加入修改几个页面那是再好不过了哈哈哈"></a><a href="">注册功能 – 如果有前端的牛人加入修改几个页面那是再好不过了哈哈哈</a></h4><h4 id="全局异常处理拦截"><a href="#全局异常处理拦截" class="headerlink" title="全局异常处理拦截"></a><a href="">全局异常处理拦截</a></h4><pre><code>1.定义全局的异常拦截器
2.定义了全局异常类型
3.只返回和业务有关的
4.详情请看GlobleException</code></pre><h4 id="页面级缓存thymeleafViewResolver"><a href="#页面级缓存thymeleafViewResolver" class="headerlink" title="页面级缓存thymeleafViewResolver"></a><a href="">页面级缓存thymeleafViewResolver</a></h4><pre><code>1.详细请看basecontroller 缓存渲染页面</code></pre><h4 id="对象级缓存redis🙋🐓"><a href="#对象级缓存redis🙋🐓" class="headerlink" title="对象级缓存redis🙋🐓"></a><a href="">对象级缓存redis🙋🐓</a></h4><pre><code>redis永久缓存对象减少压力
redis预减库存减少数据库访
内存标记方法减少redis访问</code></pre><h4 id="订单处理队列rabbitmq"><a href="#订单处理队列rabbitmq" class="headerlink" title="订单处理队列rabbitmq"></a><a href="">订单处理队列rabbitmq</a></h4><pre><code>请求先入队缓冲，异步下单，增强用户体验
请求出队，生成订单，减少库存
客户端定时轮询检查是否秒杀成功 </code></pre><h4 id="解决分布式session"><a href="#解决分布式session" class="headerlink" title="解决分布式session"></a><a href="">解决分布式session</a></h4><pre><code>--生成随机的uuid作为cookie返回并redis内存写入 
--拦截器每次拦截方法，来重新获根据cookie获取对象
--下一个页面拿到key重新获取对象
--HandlerMethodArgumentResolver 方法 supportsParameter 如果为true 执行 resolveArgument 方法获取miaoshauser对象
--如果有缓存的话 这个功能实现起来就和简单，在一个用户访问接口的时候我们把访问次数写到缓存中，在加上一个有效期。
   通过拦截器. 做一个注解 @AccessLimit 然后封装这个注解，可以有效的设置每次访问多少次，有效时间是否需要登录！</code></pre><h4 id="秒杀安全-–-安全性设计"><a href="#秒杀安全-–-安全性设计" class="headerlink" title="秒杀安全 – 安全性设计"></a><a href="">秒杀安全 – 安全性设计</a></h4><pre><code>秒杀接口隐藏
数字公式验证码
接口防刷限流(通用 注解，拦截器方式)</code></pre><h4 id="通用缓存key的封装采用什么设计模式"><a href="#通用缓存key的封装采用什么设计模式" class="headerlink" title="通用缓存key的封装采用什么设计模式"></a><a href="">通用缓存key的封装采用什么设计模式</a></h4><pre><code>模板模式的优点
-具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构
-代码复用的基本技术，在数据库设计中尤为重要
-存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”
-缺点：　每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大</code></pre><h4 id="redis的库存如何与数据库的库存保持一致"><a href="#redis的库存如何与数据库的库存保持一致" class="headerlink" title="redis的库存如何与数据库的库存保持一致"></a><a href="">redis的库存如何与数据库的库存保持一致</a></h4><pre><code>redis的数量不是库存,他的作用仅仅只是为了阻挡多余的请求透穿到DB，起到一个保护的作用
因为秒杀的商品有限，比如10个，让1万个请求区访问DB是没有意义的，因为最多也就只能10个
请求下单成功，所有这个是一个伪命题，我们是不需要保持一致的</code></pre><h4 id="redis-预减成功，DB扣减库存失败怎么办"><a href="#redis-预减成功，DB扣减库存失败怎么办" class="headerlink" title="redis 预减成功，DB扣减库存失败怎么办"></a><a href="">redis 预减成功，DB扣减库存失败怎么办</a></h4><pre><code>-其实我们可以不用太在意，对用户而言，秒杀不中是正常现象，秒杀中才是意外，单个用户秒杀中
-1.本来就是小概率事件，出现这种情况对于用户而言没有任何影响
-2.对于商户而言，本来就是为了活动拉流量人气的，卖不完还可以省一部分费用，但是活动还参与了，也就没有了任何影响
-3.对网站而言，最重要的是体验，只要网站不崩溃，对用户而言没有任何影响</code></pre><h4 id="为什么redis数量会减少为负数"><a href="#为什么redis数量会减少为负数" class="headerlink" title="为什么redis数量会减少为负数"></a><a href="">为什么redis数量会减少为负数</a></h4><pre><code>//预见库存
long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock,&quot;&quot;+goodsId) ;
if(stock &lt;0){
localOverMap.put(goodsId, true);
return Result.error(CodeMsg.MIAO_SHA_OVER);
}
假如redis的数量为1,这个时候同时过来100个请求，大家一起执行decr数量就会减少成-99这个是正常的
进行优化后改变了sql写法和内存写法则不会出现上述问题</code></pre><h4 id="为什么要单独维护一个秒杀结束标志"><a href="#为什么要单独维护一个秒杀结束标志" class="headerlink" title="为什么要单独维护一个秒杀结束标志"></a><a href="">为什么要单独维护一个秒杀结束标志</a></h4><pre><code>-1.前提所有的秒杀相关的接口都要加上活动是否结束的标志，如果结束就直接返回，包括轮寻的接口防止一直轮寻
-2.管理后台也可以手动的更改这个标志，防止出现活动开始以后就没办法结束这种意外的事件</code></pre><h4 id="rabbitmq如何做到消息不重复不丢失即使服务器重启"><a href="#rabbitmq如何做到消息不重复不丢失即使服务器重启" class="headerlink" title="rabbitmq如何做到消息不重复不丢失即使服务器重启"></a><a href="">rabbitmq如何做到消息不重复不丢失即使服务器重启</a></h4><pre><code>-1.exchange持久化
-2.queue持久化
-3.发送消息设置MessageDeliveryMode.persisent这个也是默认的行为
-4.手动确认</code></pre><h4 id="为什么threadlocal存储user对象，原理"><a href="#为什么threadlocal存储user对象，原理" class="headerlink" title="为什么threadlocal存储user对象，原理"></a><a href="">为什么threadlocal存储user对象，原理</a></h4><pre><code>1.并发编程中重要的问题就是数据共享，当你在一个线程中改变任意属性时，所有的线程都会因此受到影响，同时会看到第一个线程修改后的值&lt;br&gt;
有时我们希望如此，比如：多个线程增大或减小同一个计数器变量&lt;br&gt;
但是，有时我们希望确保每个线程，只能工作在它自己 的线程实例的拷贝上，同时不会影响其他线程的数据&lt;br&gt;

举例： 举个例子，想象你在开发一个电子商务应用，你需要为每一个控制器处理的顾客请求，生成一个唯一的事务ID，同时将其传到管理器或DAO的业务方法中，
以便记录日志。一种方案是将事务ID作为一个参数，传到所有的业务方法中。但这并不是一个好的方案，它会使代码变得冗余。   
你可以使用ThreadLocal类型的变量解决这个问题。首先在控制器或者任意一个预处理器拦截器中生成一个事务ID
然后在ThreadLocal中 设置事务ID，最后，不论这个控制器调用什么方法，都能从threadlocal中获取事务ID
而且这个应用的控制器可以同时处理多个请求，
同时在框架 层面，因为每一个请求都是在一个单独的线程中处理的，所以事务ID对于每一个线程都是唯一的，而且可以从所有线程的执行路径获取
运行结果可以看出每个线程都在维护自己的变量：
 Starting Thread: 0 : Fri Sep 21 23:05:34 CST 2018&lt;br&gt;
 Starting Thread: 2 : Fri Sep 21 23:05:34 CST 2018&lt;br&gt;
 Starting Thread: 1 : Fri Jan 02 05:36:17 CST 1970&lt;br&gt;
 Thread Finished: 1 : Fri Jan 02 05:36:17 CST 1970&lt;br&gt;
 Thread Finished: 0 : Fri Sep 21 23:05:34 CST 2018&lt;br&gt;
 Thread Finished: 2 : Fri Sep 21 23:05:34 CST 2018&lt;br&gt;

 局部线程通常使用在这样的情况下，当你有一些对象并不满足线程安全，但是你想避免在使用synchronized关键字&lt;br&gt;
 块时产生的同步访问，那么，让每个线程拥有它自己的对象实例&lt;br&gt;
 注意：局部变量是同步或局部线程的一个好的替代，它总是能够保证线程安全。唯一可能限制你这样做的是你的应用设计约束&lt;br&gt;
 所以设计threadlocal存储user不会对对象产生影响，每次进来一个请求都会产生自身的线程变量来存储</code></pre><h4 id="maven-隔离"><a href="#maven-隔离" class="headerlink" title="maven 隔离"></a><a href="">maven 隔离</a></h4><pre><code>maven隔离就是在开发中，把各个环境的隔离开来，一般分为 
 本地（local）
 开发(dev)
 测试(test)
 线上(prod)
 在环境部署中为了防止人工修改的弊端！ spring.profiles.active=@activatedProperties@</code></pre><h4 id="redis-分布式锁实现方法"><a href="#redis-分布式锁实现方法" class="headerlink" title="redis 分布式锁实现方法"></a><a href="">redis 分布式锁实现方法</a></h4><pre><code>我用了四种方法 ， 分别指出了不同版本的缺陷以及演进的过程 orderclosetask
V1----&gt;&gt;版本没有操作，在分布式系统中会造成同一时间，资源浪费而且很容易出现并发问题
V2---&gt;&gt;版本加了分布式redis锁，在访问核心方法前，加入redis锁可以阻塞其他线程访问,可以
很好的处理并发问题,但是缺陷就是如果机器突然宕机，或者线路波动等，就会造成死锁，一直
不释放等问题
V3版本--&gt;&gt;很好的解决了这个问题v2的问题，就是加入时间对比如果当前时间已经大与释放锁的时间
说明已经可以释放这个锁重新在获取锁，setget方法可以把之前的锁去掉在重新获取,旧值在于之前的
值比较，如果无变化说明这个期间没有人获取或者操作这个redis锁，则可以重新获取
V4----&gt;&gt;采用成熟的框架redisson,封装好的方法则可以直接处理，但是waittime记住要这只为0</code></pre><h4 id="服务降级–服务熔断-过载保护-）"><a href="#服务降级–服务熔断-过载保护-）" class="headerlink" title="服务降级–服务熔断(过载保护)）"></a><a href="">服务降级–服务熔断(过载保护)）</a></h4><pre><code>自动降级： 超时.失败次数,故障,限流
人工降级：秒杀，双11

9.所有秒杀相关的接口比如：秒杀，获取秒杀地址，获取秒杀结果，获取秒杀验证码都需要加上
秒杀是否开始结束的判断</code></pre><h4 id="RPC事务补偿"><a href="#RPC事务补偿" class="headerlink" title="RPC事务补偿"></a><a href="">RPC事务补偿</a></h4><pre><code>当集中式进行服务化RPC演进成分布式的时候，事务则成为了进行分布式的一个痛点，本项目的做法为：
1.进行流程初始化，当分别调用不用服务化接口的时候，成功则进行流程，失败则返回并进行状态更新
将订单状态变为回滚
2.使用定时任务不断的进行处理rollback的订单进行回滚</code></pre><h4 id="秒杀类似场景sql的写法注意事项"><a href="#秒杀类似场景sql的写法注意事项" class="headerlink" title="秒杀类似场景sql的写法注意事项"></a><a href="">秒杀类似场景sql的写法注意事项</a></h4><pre><code>1.在秒杀一类的场景里面，因为数据量亿万级所有即使有的有缓存有的时候也是扛不住的，不可避免的透穿到DB
 所有在写一些sql的时候就要注意：
 1.一定要避免全表扫描，如果扫一张大表的数据就会造成慢查询，导致数据的连接池直接塞满,导致事故
 首先考虑在where和order by 设计的列上建立索引
 例如： 1. where 子句中对字段进行 null 值判断 . 
       2. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符 
       3. 应尽量避免在 where 子句中使用 or 来连接条件
       4. in 和 not in 也要慎用，否则会导致全表扫描( 如果索引 会优先走索引 不会导致全表扫描 
        字段上建了索引后，使用in不会全表扫描，而用not in 会全表扫描 低版本的mysql是两种情况都会全表扫描。
        5.5版本后以修。而且在优化大表连接查询的时候，有一个方法就是将join操作拆分为in查询)
       5. select id from t where name like &apos;%abc%&apos; 或者
       6.select id from t where name like &apos;%abc&apos; 或者
       7. 若要提高效率，可以考虑全文检索。 
       8.而select id from t where name like &apos;abc%&apos; 才用到索引 慢查询一般在测试环境不容易复现
       9.应尽量避免在 where 子句中对字段进行表达式操作 where num/2  num=100*2
 2.合理的使用索引  索引并不是越多越好，使用不当会造成性能开销
 3.尽量避免大事务操作，提高系统并发能力
 4.尽量避免象客户端返回大量数据，如果返回则要考虑是否需求合理，实在不得已则需要在设计一波了！！！！！</code></pre><h4 id="网站访问统计实现"><a href="#网站访问统计实现" class="headerlink" title="网站访问统计实现"></a><a href="">网站访问统计实现</a></h4><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/count.png" alt="整体流程"></p>
<pre><code>利用lua脚本进行对redis操作,登陆时，每次登陆成功则记录访问（具体你想在什么时段进行统计自己说了算）</code></pre><h4 id="项目进行dubbo-ZK改造"><a href="#项目进行dubbo-ZK改造" class="headerlink" title="项目进行dubbo+ZK改造"></a><a href="">项目进行dubbo+ZK改造</a></h4><pre><code>├── miaosha-admin  登录模块
│   ├── pom.xml
│   └── miaosha-admin-api
│   └── miaosha-admin-service
│   └── miaosha-admin-web
│   └── miaosha-common
│   
│   

├── miaosha-order   订单秒杀模块
     │   ├── pom.xml
     │   └── miaosha-order-api
     │   └── miaosha-order-service
     │   └── miaosha-order-web
     │   └── miaosha-order-common
     │   
     │   

├── miaosha-message   消息模块
     │   ├── pom.xml
     │   └── miaosha-message-api
     │   └── miaosha-message-service
     │   └── miaosha-message-web
     │   └── miaosha-message-common
     │   
     │  </code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/dubbo-admin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/dubbo-admin/" class="post-title-link" itemprop="url">dubbo-admin</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:44" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:44+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="dubbo-admin-平台搭建与管理"><a href="#dubbo-admin-平台搭建与管理" class="headerlink" title="dubbo-admin 平台搭建与管理"></a>dubbo-admin 平台搭建与管理</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><h4 id="dubbo-admin-2-6-0-war包-请进入-docs-dubbo-admin-下载"><a href="#dubbo-admin-2-6-0-war包-请进入-docs-dubbo-admin-下载" class="headerlink" title="dubbo-admin-2.6.0 war包 请进入/docs/dubbo-admin/下载"></a><a href="/docs/dubbo-admin/dubbo-admin-2.6.0.war">dubbo-admin-2.6.0 war包 请进入/docs/dubbo-admin/下载</a></h4><p>1.可直接 <a href="https://github.com/apache/incubator-dubbo/releases/tag/dubbo-2.6.0" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo/releases/tag/dubbo-2.6.0</a> 下载后将dubbo-admin-2.6.0达成war包</p>
<p>2./docs/dubbo-admin/dubbo-admin-2.6.0.war获取war包 </p>
<p>3.获取后 将war包放在tomcat的webapp目录 </p>
<p>4.启动 window startup.bat linux ./bin/startup.sh 启动 – 记得安装zk客户端才可以启动成功</p>
<p>5.访问 http://端口号:8080/dubbo-admin-2.6.0/  可成功</p>
<p>6.账号密码 root/root</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/fenbushi-tcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/fenbushi-tcc/" class="post-title-link" itemprop="url">fenbushi-tcc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><blockquote>
<p>目标 （希望大家仔细研究redis.conf配置文件-本文很多基础的一带而过）</p>
</blockquote>
<pre><code>1.事物简介
2.分布式事务的前世今生
3.分布式事务解决方案
4.主流分布式事务框架介绍
整理大部分常用的场景与使用,如果有疑问或者你不懂的地方请联系我！</code></pre><h4 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1 分布式事务"></a>1 分布式事务</h4><blockquote>
<p>1.将多个节点的事务看成一个整体处理<br>2.分布式事务由事务参与者，资源服务器，事务管理器等组成<br>3.常见的分布式事务的例子： 支付，下订单等<br>4.两段式事务和三段式事务（2pc,3pc）<br>   基于XA的分布式事务<br>   基于消息的最终一致性方案<br>   TCC编程式补偿性方案</p>
</blockquote>
<p> <strong>redis分布式锁解决什么问题</strong></p>
<pre><code>1.一个进程中的多个线程,多个线程并发访问同一个资源的时候,如何解决线程安全问题。
2.一个分布式架构系统中的两个模块同时去访问一个文件对文件进行读写操作
3.多个应用对同一条数据做修改的时候,如何保证数据的安全性
在但一个进程中,我们可以用到synchronized、lock之类的同步操作去解决,但是对于分布式架构下多进程的情况下,
如何做到跨进程的锁。就需要借助一些第三方手段来完成</code></pre><p> <strong>设计一个分布式所需要解决的问题,分布式锁解决方案（数据库方案）</strong></p>
<pre><code>数据库解决方式,创建一个表叫做LOCK表
lock(
  id  int(11)
  methodName  varchar(100),--锁定的方法名称
  memo varchar(1000) 
  modifyTime timestamp
  unique key mn (method)  --唯一约束
)

在执行方法的时候,获取锁的伪代码 或者for update行锁 或者 乐观锁方式也是可以的
try{
exec  insert into lock(methodName,memo) values(‘method’,’desc’);
return true;
}Catch(DuplicateException e){
return false;
}

释放锁：
delete from lock where methodName=’’; </code></pre><p>  <strong>（数据库方案）存在的问题以及思考</strong></p>
<pre><code>1.锁没有失效时间,一旦解锁操作失败,就会导致锁记录一直在数据库中,其他线程无法再获得到锁
2.锁是非阻塞的,数据的insert操作,一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列
  要想再次获得锁就要再次触发获得锁操作
3.锁是非重入的,同一个线程在没有释放锁之前无法再次获得该锁</code></pre><p>  <strong>ZK方案</strong></p>
<pre><code>ZK方案实现之前你要先了解ZK关于他的节点的几个特性：

有序节点：假如当前有一个父节点为/lock,我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性
例如我们可以创建子节点“/lock/node-”并且指明有序,那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号
也就是说如果是第一个创建的子节点,那么生成的子节点为/lock/node-0000000000,下一个节点则为/lock/node-0000000001,依次类推

临时节点：客户端可以建立一个临时节点,在会话结束或者会话超时后,zookeeper会自动删除该节点

事件监听：在读取数据时,我们可以同时对节点设置事件监听,当节点数据或结构变化时,zookeeper会通知客户端
当前zookeeper有如下四种事件：
1）节点创建
2）节点删除
3）节点数据修改
4）子节点变更

获取分布式锁的流程  ------- 假设所空间的根节点为/lock

1.客户端连接zookeeper,并在/lock下创建临时的且有序的子节点
第一个客户端对应的子节点为/lock/lock-0000000000,第二个为/lock/lock-0000000001,以此类推

2.--避免羊群效应--客户端获取/lock下的子节点列表,判断自己创建的子节点是否为当前子节点列表中序号最小的子节点,
如果是则认为获得锁,否则监听刚好在自己之前一位的子节点删除消息,获得子节点变更通知后重复此步骤直至获得锁

3.实行业务代码

4.流程完成后,删除对应的子节点并释放锁  （Watch机制）
对应分布式开源包Curator</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/zk.png" alt="整体流程"></p>
<p>   <strong>Redis分布式锁方案</strong></p>
<pre><code>Redis 中有许多的命令都可以实现分布式锁,但是比较常用的是SETNX这个命令来实现
有多种方案代码：
1.获取锁,释放锁 代码在redismanager 里面 （简单版）</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/redislock1.png" alt="整体流程"></p>
<p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/redislock2.png" alt="整体流程"></p>
<pre><code>closeOrder也有 不过是另一种！比较复杂！！
加入时间对比如果当前时间已经大与释放锁的时间
说明已经可以释放这个锁重新在获取锁,setget方法可以把之前的锁去掉在重新获取,旧值在于之前的
值比较,如果无变化说明这个期间没有人获取或者操作这个redis锁,则可以重新获取</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/redislock3.png" alt="整体流程"></p>
<pre><code>redis有成熟的框架redission</code></pre><p>   <strong>Redis多路复用机制（看不看都行）</strong></p>
<pre><code>linux的内核会把所有外部设备都看作一个文件来操作,对一个文件的读写操作会调用内核提供的系统命令,
返回一个 file descriptor（文件描述符）。对于一个socket的读写也会有响应的描述符,称为socketfd(socket 描述符)。
而IO多路复用是指内核一旦发现进程指定的一个或者多个文件描述符IO条件准备好以后就通知该进程
IO多路复用又称为事件驱动,操作系统提供了一个功能,当某个socket可读或者可写的时候,它会给一个通知。
当配合非阻塞socket使用时,只有当系统通知我哪个描述符可读了,我才去执行read操作,可以保证每次read都能读到有效数据。
操作系统的功能通过select/pool/epoll/kqueue之类的系统调用函数来使用,这些函数可以同时监视多个描述符的读写就绪情况
,这样多个描述符的I/O操作都能在一个线程内并发交替完成,这就叫I/O多路复用,这里的复用指的是同一个线程
多路复用的优势在于用户可以在一个线程内同时处理多个socket的 io请求。达到同一个线程同时处理多个IO请求的目的。
而在同步阻塞模型中,必须通过多线程的方式才能达到目的</code></pre><p>   <strong>Redis（2.6以后）–lua脚本</strong></p>
<pre><code>1.减少网络开销,在Lua脚本中可以把多个命令放在同一个脚本中运行
2.原子操作,redis会将整个脚本作为一个整体执行,中间不会被其他命令插入。换句话说,编写脚本的过程中无需担心会出现竞态条件
3.复用性,客户端发送的脚本会永远存储在redis中,这意味着其他客户端可以复用这一脚本来完成同样的逻辑 
4.脚本可以通过return 来返回客户端  
例子： 利用lua脚本进行电话号或则IP限流 实例 具体请看 redislua类
KEYS[1] ARGV[1] ARGV[2]  key 参数1  参数2 
local num=redis.call(&apos;incr&apos;,KEYS[1])
if tonumber(num)==1 then
   redis.call(&apos;expire&apos;,KEYS[1],ARGV[1])
   return 1
elseif tonumber(num)&gt;tonumber(ARGV[2]) then
   return 0
else
   return 1
end</code></pre><p>   <strong>Redis（2.6以后）–lua–EVALSHA命令</strong></p>
<pre><code>考虑到我们通过eval执行lua脚本,脚本比较长的情况下,每次调用脚本都需要把整个脚本传给redis
比较占用带宽。为了解决这个问题,redis提供了EVALSHA命令允许开发者通过脚本内容的SHA1摘要来执行脚本。该命令的用法和EVAL一样,
只不过是将脚本内容替换成脚本内容的SHA1摘要
1. Redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中
2. 执行EVALSHA命令时Redis会根据提供的摘要从脚本缓存中查找对应的脚本内容
如果找到了就执行脚本,否则返回“NOSCRIPT No matching script,Please use EVAL”</code></pre><p>   <strong>Redis（2.6以后）–lua脚本运行限制</strong></p>
<pre><code>redis的脚本执行是原子的,即脚本执行期间Redis不会执行其他命令
所有的命令必须等待脚本执行完以后才能执行。为了防止某个脚本执行时间过程导致Redis无法提供服务
Redis提供了lua-time-limit参数限制脚本的最长运行时间--默认是5秒钟
当脚本运行时间超过这个限制后,Redis将开始接受其他命令但不会执行（以确保脚本的原子性）,而是返回BUSY的错误

在第一个窗口中执行lua脚本的死循环
eval “while true do end” 0 在第二个窗口中运行get hello    
最后第二个窗口的运行结果是Busy, 可以通过script kill命令终止正在执行的脚本
如果当前执行的lua脚本对redis的数据进行了修改,比如（set）操作,那么script kill命令没办法终止脚本的运行,
因为要保证lua脚本的原子性。如果执行一部分终止了,就违背了这一个原则
在这种情况下,只能通过 shutdown nosave命令强行终止</code></pre><p>   <strong>Redis（2.6以后）–lua分布式锁</strong></p>
<p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/lualock.png" alt="整体流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/fenbushi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/fenbushi/" class="post-title-link" itemprop="url">fenbushi</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><blockquote>
<p>分布式系统历程—-1</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi1.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-2</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi2.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-3</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi3.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-4</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi4.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-5</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi5.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-6</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi6.png" alt="整体流程"></p>
<blockquote>
<p>分布式系统历程—-7</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/fenbushi7.png" alt="整体流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/jemter-solve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/jemter-solve/" class="post-title-link" itemprop="url">jemter-solve</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="如何利用jmeter进行压测"><a href="#如何利用jmeter进行压测" class="headerlink" title="如何利用jmeter进行压测"></a>如何利用jmeter进行压测</h3><h3 id="我的服务配置较低大数据量请在自己的服务器上搞下不然就崩了"><a href="#我的服务配置较低大数据量请在自己的服务器上搞下不然就崩了" class="headerlink" title="我的服务配置较低大数据量请在自己的服务器上搞下不然就崩了"></a>我的服务配置较低大数据量请在自己的服务器上搞下不然就崩了</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><blockquote>
<p>目标 （希望大家仔细研究redis.conf配置文件-本文很多基础的一带而过）</p>
</blockquote>
<pre><code>1.如何对秒杀生成大数据量对应的用户id和token来进行压测
2.利用jmeter进行接口压测

我这个版本只是简单的测试，你仍然需要把一些接口安全的放开或者自己写一个没有安全性防刷一类的接口测试性能

如果有疑问或者你不懂的地方请联系我！</code></pre><h4 id="1-利用jmeter进行接口压测-（jmeter3-0-jdk1-7-版本以上需1-8-版本在tools里面）"><a href="#1-利用jmeter进行接口压测-（jmeter3-0-jdk1-7-版本以上需1-8-版本在tools里面）" class="headerlink" title="1 利用jmeter进行接口压测 （jmeter3.0 jdk1.7  版本以上需1.8 版本在tools里面）"></a>1 利用jmeter进行接口压测 （jmeter3.0 jdk1.7  版本以上需1.8 版本在tools里面）</h4><p> <strong>秒杀生成大数据量对应的用户id和token</strong></p>
<pre><code>在后端写模拟前端请求计算出不同的用户对应的token ， 在UserUtil类里面

生成文件格式：</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter4.png" alt="整体流程"></p>
<pre><code>代码类：</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter2.png" alt="整体流程"></p>
<p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter3.png" alt="整体流程"></p>
<pre><code>利用这个类可以生成大数据量的userId和token当前也可以自己改装生成你想要的</code></pre><p> <strong>利用jmeter进行接口压测</strong></p>
<pre><code>1.点击右键生成线程组一类的 </code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter5.png" alt="整体流程"></p>
<pre><code>2.右键线程组选择配置原件并定义http默认值</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter6.png" alt="整体流程"></p>
<pre><code>3.右键监听器可以生成聚合报告等一类的</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter7.png" alt="整体流程"></p>
<pre><code>4.右键线程组添加sampler 添加请求http请求具体情况更具实际的来</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter9.png" alt="整体流程"></p>
<pre><code>5.右键线程组添加CSV DATA Set Config  设置用户参数和token 把生成的路径引进来</code></pre><p>   <img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/jmeter8.png" alt="整体流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/jvm-goods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/jvm-goods/" class="post-title-link" itemprop="url">jvm-goods</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="生产内存环境"><a href="#生产内存环境" class="headerlink" title="生产内存环境"></a>生产内存环境</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>注重实践,不会长篇大论,纯属浪费大家时间！属于进阶文章,感谢你的支持！


解决问题：
|_ 1.生产环境发生了内存溢出该如何处理 
|_ 2.生产环境应该给服务器分配多少的内存
|_ 3.如何对垃圾回收起的性能进行调优
|_ 4.生产环境CPU的负载飙高应该如何处理
|_ 5.生产环境因该给应用分配多少的线程合适
|_ 6.不加log如何确定请求是否执行到某一段的代码 
|_ 7.实时查看某个方法的入参与返回值 
|_ 8.JVM的字节码实操
|_ 9.循环体中字符串拼接为什么效率很低 
|_ 10.string常量池怎么回事
|_ 11.用字节码分析 i++，++i 到底哪种效率高 


项目实战收获：

 |_ 1.熟练使用各种监控和调试工具 
 |_ 2.从容应对生产环境的各种调试和性能
 |_ 3.熟悉JVM字节码指令
 |_ 4.深入理解JVM自动回收机制学会GC调优
 |_ 5.基于JDK命令行的监控 |_ JVM的参数类型 
                       |_ 查看JVM运行时的参数
                       |_ Jstat查看JVM统计信息 
                       |_ 演示内存溢出
                       |_ 导出内存映像文件
                       |_ MAT分析内存溢出
                       |_ jstack与线程的状态
                       |_ jstack实战死循环与锁
 |_ 6.基于JVisualVM的可视化工具 |_ 监控本地java进程
                             |_ 监控远程java进程
 |_ 7.基于Btrace的监控调试基于Btrace的监控调试 |_ Btrace入门
                                          |_ 拦截器构造函数，同名函数
                                          |_ 拦截器返回值，异常，行号
                                          |_ 拦截器复杂参数，环境变量，正则匹配拦截
                                          |_ 注意事项                
 |_ 8.tomcat的性能监控调优 |_ tomcat远程debug
                        |_ tomcat-manager监控
                        |_ psi-probe监控 
                        |_ tomcat优化
 |_ 9.nginx的监控调优 |_ nginx的监控调优
                    |_ ngx_http_stub_status监控连接信息
                    |_ ngxtop监控请求信息
                    |_ nginx-rrd图形化监控
                    |_ nginx优化
 |_ 10.jvm+gc调优 |_ JVM的内存结构以及各个分区
                 |_ 常见垃圾回收算法
                 |_ 垃圾回收期调优
                 |_ 如何分析内存日志
                 |_ 垃圾回收器 
                 |_ GC日志格式详解
                 |_ ParallelGC调优
                 |_ G1调优</code></pre><p><strong>基于JDK命令行工具监控</strong></p>
<pre><code>|_  JVM参数类型 
|_  运行时JVM参数查看
|_  jstat查看虚拟机统计信息
|_  jmap + MAT实战内存溢出
|_  jstack 实战死锁循环与死锁</code></pre><table>
<thead>
<tr>
<th>ID</th>
<th>Problem</th>
<th align="left">Article</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>JVM参数类型</td>
<td align="left">三种: 标准参数 , X参数 ,XX 参数</td>
</tr>
<tr>
<td>001</td>
<td>如何对本项目进行jmeter压测</td>
<td align="left"><a href="https://raw.githubusercontent.com/qiurunze123/imageall/master/miaosha.png" target="_blank" rel="noopener">解决思路</a></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/linux/" class="post-title-link" itemprop="url">linux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="秒杀nginx优化"><a href="#秒杀nginx优化" class="headerlink" title="秒杀nginx优化"></a>秒杀nginx优化</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><p>##要求：</p>
<blockquote>
<p>目标</p>
</blockquote>
<pre><code>1.并发优化
2.KeepALive长连接优化
3.压缩优化
4.配置缓存</code></pre><h4 id="docs-tools-nginx-nginx优化相关包"><a href="#docs-tools-nginx-nginx优化相关包" class="headerlink" title="/docs/tools/nginx nginx优化相关包"></a><a href="/docs/tools">/docs/tools/nginx nginx优化相关包</a></h4><pre><code>安装：cd
yum install -y gcc gcc-c++
./configure --prefix=/usr/local/nginx --with-pcre=/home/qiurunze/下载/pcre-8.38 --with-http_stub_status_module --with-http_gzip_static_module --add-module=/home/qiurunze/下载/ngx_cache_purge-2.3
make
make install

 ps -ef | grep nginx

./sbin/nginx -s reload

http://nginx.org/en/docs/

1.工作线程数和并发连接数
worker_processes 4; #cpu，如果nginx单独在一台机器上
worker_processes auto;
events {
    worker_connections 4096;#每一个进程打开的最大连接数，超出了log中会有记录
    multi_accept on; #可以一次建立多个连接
    use epoll;
}
worker_rlimit_nofile 10240;每个进程打开的最大的文件数，受限于操作系统：
vi /etc/security/limits.conf
* hard nofile 102400
* soft nofile 102400
* soft core unlimited
* soft stack 10240

2.操作系统优化
配置文件/etc/sysctl.conf
sysctl -w net.ipv4.tcp_syncookies=1#防止一个套接字在有过多试图连接到达时引起过载
sysctl-w net.core.somaxconn=1024#默认128，连接队列
sysctl-w net.ipv4.tcp_fin_timeout=10 # timewait的超时时间
sysctl -w net.ipv4.tcp_tw_reuse=1 #os直接使用timewait的连接
sysctl -w net.ipv4.tcp_tw_recycle = 0 #回收禁用

3.Keepalive长连接
Nginx与upstream server：
upstream server_pool{
        server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;
        keepalive 300;  #300个长连接
}
同时要在location中设置：
location /  {
            proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
}
客户端与nginx（默认是打开的）：


4.keepalive_timeout  60s; #长连接的超时时间
keepalive_requests 100; #100个请求之后就关闭连接，可以调大
keepalive_disable msie6; #ie6禁用启用压缩
gzip on;
gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;
gzip_proxied any;
gzip_types text/html text/plain application/x-javascript application/javascript text/css application/xml
gzip_vary on; #Vary: Accept-Encoding
gzip_static on; #如果有压缩好的 直接使用



5.状态监控
location = /nginx_status {
    stub_status on;
    access_log off;
    allow &lt;YOURIPADDRESS&gt;;
    deny all;
}
输出结果：
Active connections: 1 
server accepts handled requests
 17122 17122 34873 
Reading: 0 Writing: 1 Waiting: 0 
Active connections：当前实时的并发连接数
accepts：收到的总连接数，
handled：处理的总连接数
requests：处理的总请求数
Reading：当前有都少个读，读取客户端的请求
Writing：当前有多少个写，向客户端输出
Waiting：当前有多少个长连接（reading + writing）
reading – nginx reads request header
writing – nginx reads request body, processes request, or writes response to a client
waiting – keep-alive connections, actually it is active - (reading + writing)

6.实时请求信息统计ngxtop
https://github.com/lebinh/ngxtop
(1)安装python-pip
yum install epel-release
yum install python-pip
(2)安装ngxtop
pip install ngxtop
(3)使用
指定配置文件：           ngxtop -c ./conf/nginx.conf
查询状态是200：        ngxtop -c ./conf/nginx.conf  --filter &apos;status == 200&apos;
查询那个ip访问最多： ngxtop -c ./conf/nginx.conf  --group-by remote_addr

-----------------------------------------------------------------------------
nginx.conf配置文件 
user  www;
worker_processes  4;#取决于cpu

error_log  logs/error.log;

pid        logs/nginx.pid;

worker_rlimit_nofile 10240; #每个进程打开的最大的文件数，受限于操作系统/etc/security/limits.conf

events {
    worker_connections 10240;#每一个进程打开的最大连接数，超出了log中会有记录
    multi_accept on; #可以一次建立多个连接
    use epoll;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    server_tokens off; #隐藏版本号
    client_max_body_size 10m; #文件上传需要调大

    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

    access_log  logs/access.log  main;
    #默认写日志：打开文件写入关闭，max:缓存的文件描述符数量，inactive缓存时间，valid：检查时间间隔，min_uses：在inactive时间段内使用了多少次加入缓存
    open_log_file_cache max=200 inactive=20s valid=1m min_uses=2;

    sendfile       on;
    tcp_nopush     on;
    #与浏览器的长连接
    keepalive_timeout  65;#长连接超时时间
    keepalive_requests 500;#500个请求以后，关闭长连接
    keepalive_disable msie6;
    # 启用压缩
    gzip on;
    gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;
    gzip_proxied any;
    gzip_types text/plain application/x-javascript application/javascript text/css application/xml;
    gzip_vary on; #Vary: Accept-Encoding
    gzip_static on; #如果有压缩好的 直接使用
    #超时时间
    proxy_connect_timeout 5; #连接proxy超时
    proxy_send_timeout 5; # proxy连接nginx超时
    proxy_read_timeout 60;# proxy响应超时
     # 开启缓存,2级目录
    proxy_cache_path /usr/local/nginx/proxy_cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=20g;
    proxy_ignore_headers X-Accel-Expires Expires Cache-Control;
    proxy_hide_header Cache-Control;
    proxy_hide_header Pragma;

    #反向代理服务器集群
    upstream server_pool{
        server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;
        server localhost:8081 weight=1 max_fails=2 fail_timeout=30s; 
        keepalive 200; # 最大的空闲的长连接数 
    }

    server {
        listen       80;
        server_name  localhost 192.168.220.133;

        location / {
            #长连接
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
            #Tomcat获取真实用户ip
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Forwarded-Proto  $scheme;
            proxy_pass http://server_pool;
        }
        # 状态监控
        location /nginx_status {
            stub_status on;
            access_log   off;
            allow 127.0.0.1;
            allow 192.168.220.133;
            deny all;
        }
        #用于清除缓存
        location ~ /purge(/.*)
        {
            allow 127.0.0.1;
            allow 192.168.220.133;
            deny all;
            proxy_cache_purge cache_one $host$1$is_args$args;
        }
        # 静态文件加缓存
        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css|html|htm)?$
        {
            expires 1d;
            proxy_cache cache_one;
            proxy_cache_valid 200 304 1d;
            proxy_cache_valid any 1m;
            proxy_cache_key $host$uri$is_args$args;
            proxy_pass http://server_pool;
        }
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/maven-wrapper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/maven-wrapper/" class="post-title-link" itemprop="url">maven-wrapper</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="maven-wrapper"><a href="#maven-wrapper" class="headerlink" title="maven wrapper"></a>maven wrapper</h3><pre><code>下载项目, 切换的项目根目录
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux/Mac:</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">cd</span> miaosha/</span><br><span class="line">&gt; ./mvnw clean install</span><br><span class="line"></span><br><span class="line">Windows:</span><br><span class="line">&gt; mvnw.cmd clean install</span><br></pre></td></tr></table></figure>
   运行以上命令相关依赖便会安装完毕
   启动GeekQMainApplication主类即可
  若有对于./mvnw 不了解的请点击下方链接介绍</code></pre><blockquote>
<p>传统maven的使用流程</p>
</blockquote>
<pre><code>1. 传统使用maven需要先到官网上下载.
2. 配置环境变量把mvn可执行文件路径加入到环境变量，以便之后使用直接使用mvn命令.
3. 另外项目pom.xml文件描述的依赖文件默认是下载在用户目录下的.m2文件下的repository目录下.
4. 再次，如果需要更换maven的版本，需要重新下载maven并替换环境变量path中的maven路径.</code></pre><blockquote>
<p>maven-wrapper，会获得以下特性</p>
</blockquote>
<pre><code>执行mvnw比如./mvnw clean ，如果本地没有匹配的maven版本，直接会去下载maven，放在用户目录下的.m2/wrapper中
并且项目的依赖的jar包会直接放在项目目录下的repository目录，这样可以很清晰看到当前项目的依赖文件。
如果需要更换maven的版本，只需要更改项目当前目录下.mvn/wrapper/maven-wrapper.properties的distributionUrl属性值，更换对应版本的maven下载地址。mvnw命令就会自动重新下载maven。
可以说带有mvnw文件的项目，除了额外需要配置 java环境外，只需要使用本项目的mvnw脚本就可以完成编译，打包，发布等一系列操作。</code></pre><blockquote>
<p>如何使用呢？</p>
</blockquote>
<pre><code>通常我们在使用maven的时候会执行如下一些命令：
mvn clean
mvn install
mvn package
...

使用maven wrapper之后只需打开terminal 执行如下等价命令即可：
linux:
    ./mvnw clean
    ./mvnw install
    ./mvnw package
    ...

windows:
    mvnw.cmd clean
    mvnw.cmd install
    mvnw.cmd package
    ...</code></pre><blockquote>
<p>Get Started! </p>
</blockquote>
<pre><code>因此大家在下载项目代码之后, 只需要执行 ./mvn clean install 
maven warpper 便会自动为该项目构建maven环境.
当然如果大家用的IDE是idea 那么依然也可以使用右上方的MavenProject Panel 鼠标触发各个Task</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/17/mybatis-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="太阳战士">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余生的第一天">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/mybatis-code/" class="post-title-link" itemprop="url">mybatis-code</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-17 21:43:43" itemprop="dateCreated datePublished" datetime="2020-01-17T21:43:43+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-12 11:11:38" itemprop="dateModified" datetime="2019-06-12T11:11:38+08:00">2019-06-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="mybatis使用与总结"><a href="#mybatis使用与总结" class="headerlink" title="mybatis使用与总结"></a>mybatis使用与总结</h3><pre><code>有问题或者宝贵意见联系我的QQ,非常希望你的加入！</code></pre><blockquote>
<p>mybatis 使用总结</p>
</blockquote>
<h4 id="resultType-和-resultMap"><a href="#resultType-和-resultMap" class="headerlink" title="resultType 和 resultMap"></a>resultType 和 resultMap</h4><pre><code>MyBatis的每一个查询映射的返回类型都是ResultMap，
只是当我们提供的返回类型属性是resultType的时候，MyBatis对自动的给我们把对应的值赋给resultType所指定对象的属性，
而当我们提供的返回类型是resultMap的时候，将数据库中列数据复制到对象的相应属性上，可以用于复制查询，两者不能同时用。</code></pre><h4 id="typeAliases类型命名"><a href="#typeAliases类型命名" class="headerlink" title="typeAliases类型命名"></a>typeAliases类型命名</h4><pre><code>存在的意义在于减少类的完全限定名的冗余

_user可以用在任何需要com.geekq.miaosha.mybatis.User</code></pre><h3 id="当实体类中的属性名和表中的字段名不一致时使用MyBatis进行查询操作时无法查询出相应的结果的问题以及针对问题采用的两种办法"><a href="#当实体类中的属性名和表中的字段名不一致时使用MyBatis进行查询操作时无法查询出相应的结果的问题以及针对问题采用的两种办法" class="headerlink" title="当实体类中的属性名和表中的字段名不一致时使用MyBatis进行查询操作时无法查询出相应的结果的问题以及针对问题采用的两种办法"></a>当实体类中的属性名和表中的字段名不一致时使用MyBatis进行查询操作时无法查询出相应的结果的问题以及针对问题采用的两种办法</h3><pre><code>解决办法一: 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致，
这样就可以表的字段名和实体类的属性名一一对应上了，这种方式是通过在sql语句中定义别名来解决字段名和属性名的映射关系的
解决办法二: 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应关系。
这种方式是使用MyBatis提供的解决方式来解决字段名和属性名的映射关系的。</code></pre><h3 id="为什么order-by-要用-xxx-而不用"><a href="#为什么order-by-要用-xxx-而不用" class="headerlink" title="为什么order by 要用${xxx} 而不用 #{}"></a>为什么order by 要用${xxx} 而不用 #{}</h3><pre><code>对于形如#{variable}
 的变量，Mybatis会将其视为字符串值，在变量替换成功后，缺省地给变量值加上引号。&quot;variable&quot;
 （2）对于形如${variable}的变量，Mybatis会将其视作直接变量，即在变量替换成功后，不会再给其加上引号。
     variable
 所以在动态sql中，#{variable}
 需要去掉 &quot;&quot;，比如正常sql赋值一般是这样的and name= #{name},因为是=赋值，所以会获取内容，去掉&quot;&quot;
${variable}可以直接使用,比如order
 by ${name}   传入的直接是name，不带双引号，可以直接使用，
并且order
 by不是 =赋值，所以如果直接order by #{name}，结果是order
 by &quot;name&quot;，自然无法执行了</code></pre><h3 id="如何打印sql日志"><a href="#如何打印sql日志" class="headerlink" title="如何打印sql日志 ?"></a>如何打印sql日志 ?</h3><pre><code>xml方式
&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;clone&quot;/&gt;
&lt;!-- 打印查询语句 打印mybatis日志--&gt;
&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;

配置方式：

#打印mybatis sql
log4j.logger.com.ibatis=DEBUG
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG
log4j.logger.Java.sql.Connection=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG</code></pre><h3 id="动态sql标签"><a href="#动态sql标签" class="headerlink" title="动态sql标签"></a>动态sql标签</h3><pre><code>if
choose (when, otherwise)
trim (where, set)
foreach</code></pre><h3 id="如何使用mybatis-generator-generate"><a href="#如何使用mybatis-generator-generate" class="headerlink" title="如何使用mybatis-generator:generate"></a>如何使用mybatis-generator:generate</h3><pre><code>pom 配置：

 &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;false&lt;/overwrite&gt;
                &lt;/configuration&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;mysql&lt;/groupId&gt;
                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                        &lt;version&gt;5.1.21&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/plugin&gt;</code></pre><p><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/mybatis1.png" alt="使用"><br><img src="https://raw.githubusercontent.com/qiurunze123/imageall/master/mybatis2.png" alt="使用"></p>
<h3 id="generatorConfig-xml-内容解析"><a href="#generatorConfig-xml-内容解析" class="headerlink" title="generatorConfig.xml 内容解析?"></a>generatorConfig.xml 内容解析?</h3><pre><code>已在其中备注,详细内容请见generatorConfig.xml</code></pre><h3 id="xml映射文件都会有一个dao接口，工作原理？"><a href="#xml映射文件都会有一个dao接口，工作原理？" class="headerlink" title="xml映射文件都会有一个dao接口，工作原理？"></a>xml映射文件都会有一个dao接口，工作原理？</h3><pre><code>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。      
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，
代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">太阳战士</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">太阳战士</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
